# app.py
from flask import Flask, request, jsonify
from math import ceil
from statistics import mean
from collections import defaultdict
import pymysql
from datetime import date as _date

DB_HOST = 'database-1.cj24wem202yj.us-east-1.rds.amazonaws.com'
DB_USER = 'admin'
DB_PASS = 'tripleS1234!'  # ⚠️ 해커톤 데모용. 깃에는 절대 올리지 말기
DB_NAME = 'fooddb'

app = Flask(__name__)
app.config['JSON_AS_ASCII'] = False
app.config['JSONIFY_MIMETYPE'] = "application/json; charset=utf-8"

def _ensure_orders_table():
    conn = pymysql.connect(
        host=DB_HOST, user=DB_USER, password=DB_PASS,
        database=DB_NAME, charset='utf8mb4', autocommit=True
    )
    with conn.cursor() as cur:
        cur.execute("""
        CREATE TABLE IF NOT EXISTS ingredient_orders(
            id BIGINT AUTO_INCREMENT PRIMARY KEY,
            item_name VARCHAR(100),
            need DOUBLE,
            have DOUBLE,
            order_qty DOUBLE,
            pack_size DOUBLE,
            order_date DATE,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        ) CHARACTER SET utf8mb4
        """)
    conn.close()

def compute_ingredient_recommend(payload):
    sales7d       = payload.get("sales7d", {})             # {메뉴: [최근7일판매]}
    recipes       = payload.get("recipes", {})             # {메뉴: {재료: 1개당 필요량}}
    stock_ing     = payload.get("stock_ingredient", {})    # {재료: 현재고}
    package_meta  = payload.get("package_meta", {})        # {재료: 발주단위(숫자)}
    safety_stock  = payload.get("safety_stock", {})        # {재료: 안전재고(최소보유)}
    lead_days     = int(payload.get("lead_days", 1) or 1)  # 리드타임(일)

    # 1) 메뉴별 오늘 예상 판매량(단순 7일 평균)
    forecast = {m: (round(mean(v)) if v else 0) for m, v in sales7d.items()}

    # 2) 재료 필요량(일) 집계 → 리드타임 반영
    daily_need = defaultdict(float)
    for menu, qty in forecast.items():
        if qty <= 0 or menu not in recipes:
            continue
        for ing, per_unit in recipes[menu].items():
            daily_need[ing] += float(per_unit) * qty
    need_total = {ing: amt * max(1, lead_days) for ing, amt in daily_need.items()}

    # 3) 안전재고 반영
    for ing, ss in (safety_stock or {}).items():
        have = float(stock_ing.get(ing, 0) or 0)
        gap = float(ss) - have
        if gap > 0:
            need_total[ing] = need_total.get(ing, 0.0) + gap

    # 4) 부족량 및 발주단위 반올림
    recs = []
    for ing, need_amt in need_total.items():
        have_amt = float(stock_ing.get(ing, 0) or 0)
        order_amt = need_amt - have_amt
        if order_amt <= 0:
            continue
        pack = float(package_meta.get(ing, 1) or 1)
        if pack <= 0: pack = 1.0
        order_rounded = ceil(order_amt / pack) * pack
        recs.append({
            "item": ing,                         # 재료명
            "have": round(have_amt, 2),          # 남은 수량
            "need": round(need_amt, 2),          # 예상 소비량(리드타임/안전재고 반영)
            "order": round(order_rounded, 2),    # 추천 발주량(단위 반올림)
            "order_raw": round(order_amt, 2),
            "pack_size": int(pack) if float(pack).is_integer() else pack
        })

    recs.sort(key=lambda x: x["order"], reverse=True)
    return recs, forecast

def save_orders_to_db(ingredient_recommend, date_str):
    _ensure_orders_table()
    # 날짜 기본값: 오늘
    if not date_str:
        date_str = _date.today().strftime("%Y-%m-%d")

    conn = pymysql.connect(
        host=DB_HOST, user=DB_USER, password=DB_PASS,
        database=DB_NAME, charset='utf8mb4'
    )
    with conn:
        with conn.cursor() as cur:
            for rec in ingredient_recommend:
                cur.execute("""
                    INSERT INTO ingredient_orders
                    (item_name, need, have, order_qty, pack_size, order_date)
                    VALUES (%s, %s, %s, %s, %s, %s)
                """, (
                    rec["item"], rec["need"], rec["have"],
                    rec["order"], rec["pack_size"], date_str
                ))
                
def _get_monthly_average(year, month, menu):
    """월별 평균 일일 판매량"""
    conn = pymysql.connect(
        host=DB_HOST, user=DB_USER, password=DB_PASS,
        database=DB_NAME, charset='utf8mb4'
    )
    with conn.cursor() as cur:
        cur.execute("""
            SELECT 
                COALESCE(AVG(quantity), 0) as avg_qty,
                COUNT(DISTINCT sale_date) as days
            FROM sales_history
            WHERE YEAR(sale_date) = %s 
              AND MONTH(sale_date) = %s
              AND menu_name = %s
        """, (year, month, menu))
        result = cur.fetchone()
    conn.close()
    
    avg_qty = result[0] if result else 0
    return round(avg_qty, 1)  # 소수점 1자리

@app.route("/forecast", methods=["POST"])
def forecast_endpoint():
    """
    로컬 개발/테스트용 엔드포인트 (배포는 Lambda의 /predict 사용 권장)
    """
    payload = request.get_json(force=True, silent=True) or {}
    ingredient_recs, forecast = compute_ingredient_recommend(payload)
    menu_forecast = [{"item": m, "expected_sales": s} for m, s in forecast.items()]
    summary = "발주 권장 품목 없음" if not ingredient_recs else f"{len(ingredient_recs)}개 재료 발주 필요"

    # DB 저장 (옵션)
    if ingredient_recs:
        save_orders_to_db(ingredient_recs, payload.get("date"))

    compact = bool(payload.get("compact", False))
    if compact:
        ing_min = [{"item": r["item"], "have": r["have"], "need": r["need"], "order": r["order"]} for r in ingredient_recs]
        return jsonify({"summary": summary, "ingredient_recommend": ing_min, "menu_forecast": menu_forecast})

    return jsonify({
        "date": payload.get("date"),
        "summary": summary,
        "menu_forecast": menu_forecast,
        "ingredient_recommend": ingredient_recs
    })

if __name__ == "__main__":
    app.config['JSON_AS_ASCII'] = False
    app.run(host="0.0.0.0", port=8080, debug=True, use_reloader=False)
